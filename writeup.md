
Path Planning Project writeup - Term 3 Project (PPP)
Self-Driving Car Engineer Nanodegree Program

---

The goal in this project was to build a path planner that creates smooth, safe trajectories for the car to follow a simulated highway track that has other vehicles, all going at different speeds, but approximately obeying the 50 MPH speed limit. The car transmits its location, along with its sensor fusion data, which estimates the location of all the vehicles on the same side of the road.

## Implementation
The path planner implementation as a part of this project outputs a list of x and y global map coordinates. Each pair of x and y coordinates is a point, and all of the points together form a trajectory. The x list is the same length as the y list.Every 20 ms the car moves to the next point on the list. The car's new rotation becomes the line between the previous waypoint and the car's new location.

The implementation also utlizes the sensor fusion data, with the localization of rest of the vehicles. 

The implementation also accounts for constraints on maximum speed and maximum normal, tangential and total accelerations which helps minimize the `jerk acceleratation` which is measured as a rate of change of the total acceleration. The implementation implements a simple state machine to model the behavioural planning aspects of the car with the behaviour of the rest of the vehicles on the track. 

## Path Planner Movement

The basic movement of the car is given by incrementing the position of the car longitudinally i.e the  `s` value in Frenet coordinates, while keeping the lateral i.e `d` value the same. The plan builds a 50 points plan. The new path starts with whatever the previous path points were left from the previous cycle. These get appended to new waypoints, until the new path has 50 total waypoints. Using previous path values ensures that there is a smooth transition cycle to cycle. The new path is provided every 20 ms.

The points in the segment is spaced in a way so that the desired speed is met. The number of points is given by:
 
```
N = segment_length / (time_delta * velocity /2.24);
```

Here, `segment_length` is an arbitrary reference distance, `time_delta` is the time in which the car will move between two points(given as 20ms.), and `velocity` is the target speed.


To generate smooth transitions between points, hence minimizing the `jerk` measuremente, a cubic spline from three calculated points in the road, spaced 30 meters is used. The cubic spline C++ implementation at http://kluge.in-chemnitz.de/opensource/spline/ was  used. First, the desired points are generated and set them into two vectors, for the `x` and `y` coordinates:

```
// Generate spline points
vector<int> steps = {30,60,90};
for(int i = 0; i<steps.size(); i++){
    vector<double> next_wp = getXY(car_s + steps[i],(2+4*lane), map_waypoints_s,map_waypoints_x,map_waypoints_y);
    pts_x.push_back(next_wp[0]);
    pts_y.push_back(next_wp[1]);
}
```

Here the `s` coordinate is incremented in 30 meters on each step, while the `d` position is generated according to the desired lane location. Each lane is 4 meters wide, so to locate the car in the center of the lane we add 2 extra meters to the coordinate. `getXY` returns the transformed `x`, `y` map coordinates, which we will transform later to car-relative coordinates to simplify the calculations.

The spline points are initialized and set as follow :
```
tk::spline s;
s.set_points(pts_x, pts_y);
```

Once a spline is ready new points are generated by spacing them so that the number of points obtained above fit in the segment. It's easy to get the `y` coordinate of a point in the 
spline by just evaluating it on a known `x` coordinate:
```
double y_point = s(x_point);
```
 
Before adding the points to the vector that is returned to the simulator, the points are transferred back to map-relative using the code below:
 ```
// transform back to map-relative coordinates
x_point = (x_ref * cos(ref_yaw) - y_ref * sin(ref_yaw));
y_point = (x_ref * sin(ref_yaw) + y_ref * cos(ref_yaw));

x_point += ref_x;
y_point += ref_y;

next_x_vals.push_back(x_point);
next_y_vals.push_back(y_point);
```

## Changing Lanes

The implementation contains a very simple state machine to depict the behaviour planning for lane navigation. The sensor fusion data is used to determine the current location and speeds of cars around it. The below block of code shows how the next location of the car is determined if it were to continue on the same lane. If there is any other car in front of our car it was flagged and the speed of that car was saved in a variable. If there were any cars in adjacent lanes both looking ahead and back then a variable is maintained to flag that data too. This information is useful to determine what the next state of the car should be.
```
        if(car_in_front ) {
          if(lane > 0 && !car_on_left_lane) {
                    state = GO_LEFT;
          } else if (lane < 2 && !car_on_right_lane){
                    state = GO_RIGHT;
          } else if(ref_vel > car_in_front_speed){
                    state = SLOW_DOWN;
          } else {
                    state = KEEP_SAME_SPEED;
          }
        } else {
                state = STAY_IN_SAME_LANE;
        }
```
## Conclusion
[![Displaying the total statistics collected from the simulator by letting the car run across the simulated high way track for a complete loop of around 4.4 miles with any incident like collison, jert acceleration etc.](https://github.com/bhatiarajesh/CarND-Path-Planning-Project/raw/master/out/CarND-Path-Planning-Project.png)]

In conclusion, this implementation drives incident free almost indefinetly around the highway track in the simulator. A more complex stat machine could be implemented for matching speeds of cars when changing lanes. Also, possibly more smoothing could be implemented by solving some polynomial function to interpolate the location of a new point with more accuracy.
 

